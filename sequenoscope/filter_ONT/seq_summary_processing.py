#!/usr/bin/env python
import os
from sequenoscope.constant import DefaultValues
import sys

class SeqSummaryProcesser:
    parsed_report_object = None
    out_dir = None
    out_prefix = None
    classification = None
    min_ch = None
    max_ch = None
    min_dur = None
    max_dur = None
    min_start_time = None
    max_start_time = None
    min_q = None
    max_q = None
    min_len = None
    max_len = None
    status = False
    status_read_id = False
    error_messages = None
    result_files = {"filtered_read_id_list":""}
    classes = {"stop_receiving":["signal_positive"], "unblocked":["data_service_unblock_mux_change"],
               "no_decision":["signal_negative", "unblock_mux_change"], "all":["signal_positive", "data_service_unblock_mux_change", "signal_negative", "unblock_mux_change"]}

    def __init__(self, parsed_report_object, out_dir, out_prefix, classification="all", min_ch=0, max_ch=DefaultValues.max_nanopore_channel, min_dur=0, max_dur=None,
                 min_start_time=0, max_start_time=None, min_q=0, max_q=None, min_len=0, max_len=None ):
        """
        Initalize the class with parsed_report_object, out_dir, and out_prefix

        Arguments:
            parsed_report_object: parser object
                an object that contains the parsed sequencing summary report for analysis
            out_prefix: str
                a designation of what the output files will be named
            out_dir: str
                a designation of what the output files will be stored
            classification: str
                a designation of the adaptive sampling classification based on the sequencing 
                summary file generated by ONT
            min_ch: integer
                a designation that indicates the minimum channel number in an ONT run
            max_ch: integer
                a designation that indicates the maximum channel number in an ONT run
            min_dur: integer
                a designation that indicates the minimum duration a read has undergone in an ONT run
            max_dur: integer
                a designation that indicates the maximum duration a read has undergone in an ONT run
            min_start_time: integer
                a designation that indicates the minimum start time in seconds for reads
            max_start_time: integer
                a designation that indicates the maximum start time in seconds for reads
            min_q = integer
                a designation that indicates the minimum q-score of reads in an ONT run
            max_q = integer
                a designation that indicates the maximum q-score of reads in an ONT run
            min_len = len
                a designation that indicates the minimum length of a sequence for the reads in an ONT run
            max_len = len
                a designation that indicates the maximum length of a sequence for the reads in an ONT run
        """
        self.parsed_report_object = parsed_report_object.parsed_file
        self.out_dir = out_dir
        self.out_prefix = out_prefix
        self.classification = self.classes[classification]
        self.min_ch = min_ch
        self.max_ch = max_ch
        self.min_dur = min_dur
        self.max_dur = max_ch
        # if max_dur is None and 'duration' in self.parsed_report_object.columns:
        #     self.max_ch = max_dur or max(self.parsed_report_object.channel)

        self.min_start_time = min_start_time
        self.max_start_time = max_start_time
        # if max_start_time is None and 'start_time' in self.parsed_report_object.columns:
        #     self.max_start_time = max_start_time or max(self.parsed_report_object.start_time)
        
        self.min_q = min_q
        self.max_q = max_q
        # if max_q is None and 'mean_qscore_template' in self.parsed_report_object.columns:
        #     self.max_q = max_q or max(self.parsed_report_object.mean_qscore_template)
        
        self.min_len = min_len
        self.max_len = max_len
        # if max_len is None and 'sequence_length_template' in self.parsed_report_object.columns:
        #     self.max_len = max_len or max(self.parsed_report_object.sequence_length_template)

    def generate_read_ids(self):

        read_id_list = os.path.join(self.out_dir,"{}.csv".format(self.out_prefix))
        self.result_files["filtered_read_id_list"] = read_id_list

        filtered_reads = self.parsed_report_object

        if 'read_id' not in filtered_reads.columns:
            try:
                raise ValueError("The 'read_id' column was not found in the sequencing summary. Please check your input file.")
            except ValueError:
                print("-"*40)
                print("Error: The 'read_id' column was not found in the sequencing summary. Please check your input file.")
                print("-"*40)
                sys.exit()
                

        # Apply filters one by one, only if the corresponding column is present
        if "end_reason" in filtered_reads.columns:
            filtered_reads = filtered_reads[filtered_reads["end_reason"].isin(self.classification)]

        if 'channel' in filtered_reads.columns:
            filtered_reads = filtered_reads[filtered_reads.channel.between(self.min_ch, self.max_ch)]

        if 'duration' in filtered_reads.columns:
            filtered_reads = filtered_reads[filtered_reads.duration.between(self.min_dur, self.max_dur)]

        if 'start_time' in filtered_reads.columns:
            filtered_reads = filtered_reads[filtered_reads.start_time.between(self.min_start_time, self.max_start_time)]

        if 'mean_qscore_template' in filtered_reads.columns:
            filtered_reads = filtered_reads[filtered_reads.mean_qscore_template.between(self.min_q, self.max_q)]

        if 'sequence_length_template' in filtered_reads.columns:
            filtered_reads = filtered_reads[filtered_reads.sequence_length_template.between(self.min_len, self.max_len)]
        
        filtered_reads[["read_id"]].to_csv(read_id_list, index=False)

        self.status = self.check_files([read_id_list])
        if self.status == False:
            self.error_messages = "one or more files was not created or was empty"
            raise ValueError(str(self.error_messages))
        else:
            self.status_read_id = self.check_read_id_file(read_id_list)
            if self.status_read_id == False:
                self.error_messages = "File has less than 2 lines. No reads that match filtering criteria"
                raise ValueError(str(self.error_messages))
        pass

    def check_files(self, files_to_check):
        """
        check if the output file exists and is not empty

        Arguments:
            files_to_check: list
                list of file paths

        Returns:
            bool:
                returns True if the generated output file is found and not empty, False otherwise
        """
        if isinstance (files_to_check, str):
            files_to_check = [files_to_check]
        for f in files_to_check:
            if not os.path.isfile(f):
                return False
            elif os.path.getsize(f) == 0:
                return False
        return True
    
    def check_read_id_file(self, file):
        """
        check if the read id file has more than 1 line

        Arguments:
            file: str
                designation of read_id file path

        Returns:
            bool:
                returns True if the generated read_id file has greater than 2 lines, False otherwise
        """
        with open(file, "r") as f:
            lines = f.readlines()

        if not lines or len(lines) < 2:
            return False
        
        return True